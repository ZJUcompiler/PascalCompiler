/*************************************************************************
 > File Name: x86.c
 > Author: Hac
 > Mail: hac@zju.edu.cn
 > Created Time: Thu 16 Jun 2016 09:07:41 PM CST
 ************************************************************************/

#include "stdio.h"
#include <string.h>
#include <x86.h>
#include <globals.h>
FILE *CODE;

static int jmpLabel = 0;

static void regMap(const char *ir_name, char regID[]) {
    if (strcmp(ir_name, "t0") == 0)
        strcpy(regID, "eax");
    else if (strcmp(ir_name, "t1") == 0)
        strcpy(regID, "ebx");
    else if (strcmp(ir_name, "t6") == 0)
        strcpy(regID, "edx");
    else if (strcmp(ir_name, "t7") == 0)
        strcpy(regID, "edi");
}
static inline int isGE(const char *comm) {
    return strcmp(comm, "ge") == 0;
}
static inline int isGT(const char *comm) {
    return strcmp(comm, "gt") == 0;
}
static inline int isLE(const char *comm) {
    return strcmp(comm, "le") == 0;
}
static inline int isLT(const char *comm) {
    return strcmp(comm, "lt") == 0;
}
static inline int isEQ(const char *comm) {
    return strcmp(comm, "eq") == 0;
}
static inline int isNEQ(const char *comm) {
    return strcmp(comm, "neq") == 0;
}
static inline int isADD(const char *comm) {
    return strcmp(comm, "add") == 0;
}
static inline int isSUB(const char *comm) {
    return strcmp(comm, "sub") == 0;
}
static inline int isOR(const char *comm) {
    return strcmp(comm, "or") == 0;
}
static inline int isAND(const char *comm) {
    return strcmp(comm, "and") == 0;
}
static inline int isMUL(const char *comm) {
    return strcmp(comm, "mul") == 0;
}
static inline int isDIV(const char *comm) {
    return strcmp(comm, "div") == 0;
}
static inline int isMOD(const char *comm) {
    return strcmp(comm, "mod") == 0;
}
static inline int isASN(const char *comm) {
    return strcmp(comm, "asn") == 0;
}
static inline int isCALL(const char *comm) {
    return strcmp(comm, "call") == 0;
}
static inline int isARG(const char *comm) {
    return strcmp(comm, "arg") == 0;
}
static inline int isIF(const char *comm) {
    return strcmp(comm, "if_f") == 0;
}
static inline int isJMP(const char *comm) {
    return strcmp(comm, "jmp") == 0;
}
static int getMaxMemLoc(symbolNode *start) {
    return 16;
    symbolNodeCon *node;
    int cnt = 0, maxMemLoc = 0;
    while (cnt < BUFFER_SIZE) {
        node = *(start + cnt);
        while (node != NULL) {
            if (node->memloc > maxMemLoc)
                maxMemLoc = node->memloc;
            node = node->nextNode;
        }
        cnt++;
    }
}
static int labelCheck(char line[]) {
    char *tok;
    tok = strtok(line, " \r\n");
    if (tok != NULL) {
        if (tok[0] != '_')
            return -1; // not Label
        switch (tok[2]) {
            case 'M':
                return 1; // _$MAIN$_Lx: main program
            case 'P':
                return 2; // _$PROC$_Lx: procedure or function
            case 'J':
                return 3; // _$JUMP$_Lx: jump label
            case 'C':
                return 4;// _$CONST$_Lx: const data
        }
    }
    return 0; // empty line
}

static void makeStack(int stackSize) {
    fprintf(CODE, "pushl \%ebp\n");
    fprintf(CODE, "movl \%esp, \%ebp\n");
    fprintf(CODE, "subl $%d, \%esp\n", stackSize);
}

static void genPreDecl() {
    fprintf(CODE, "\t.file \"test.pas\"\n");
    fprintf(CODE, "##########################\n");
    fprintf(CODE, "#    Generated by PasC   #\n");
    fprintf(CODE, "##########################\n");
    fprintf(CODE, "\n");
}
static void genPostDecl() {
    fprintf(CODE, ".ident\t\"PasC v1.0\"\n");
    fprintf(CODE, ".section\t.node.GNU-stack,\"\",@progbits\n");
}
static void genInst(char *line) {
    char comm[8], adr1[256], adr2[256], adr3[256];
    char reg1[8], reg2[8], reg3[8];
    sscanf(line, "%s %s %s %s\n", comm, adr1, adr2, adr3);
    regMap(adr1, reg1);
    regMap(adr2, reg2);
    regMap(adr3, reg3);
    if (isADD(comm)) {
        if (strcmp(adr1, adr3) == 0)
            fprintf(CODE, "\taddl\t%s, %s\n", reg2, reg3);
        else if (strcmp(adr2, adr3) == 0)
            fprintf(CODE, "\taddl\t%s, %s\n", reg1, reg3);
        else {
            fprintf(CODE, "\taddl\t%s, %s\n", reg1, reg2);
            fprintf(CODE, "\tmovl\t%s, %s\n", reg2, reg3);
        }
    }
    else if (isSUB(comm)) {
        if (strcmp(adr1, adr3) == 0)
            fprintf(CODE, "\tsubl\t%s, %s\n", reg2, reg3);
        else if (strcmp(adr2, adr3) == 0) {
            fprintf(CODE, "\tsubl\t%s, %s\n", reg2, reg1);
            fprintf(CODE, "\tmovl\t%s, %s\n", reg1, reg3);
        }
        else {
            fprintf(CODE, "\tsubl\t%s, %s\n", reg2, reg1);
            fprintf(CODE, "\tmovl\t%s, %s\n", reg1, reg3);
        }
    }
    else if (isOR(comm)) {
        fprintf(CODE, "\tcmpl\t$0, %s\n", reg1);
        fprintf(CODE, "\tjne\t.L%d\n", jmpLabel);
        fprintf(CODE, "\tcmpl\t$0, %s\n", reg2);
        fprintf(CODE, "\tje\t.L%d\n", jmpLabel+1);
        fprintf(CODE, ".L%d:\n", jmpLabel);
        fprintf(CODE, "\tmovl\t$1, %s\n", reg3);
        fprintf(CODE, "\tjmp\t.L%d\n", jmpLabel+2);
        fprintf(CODE, ".L%d:\n", jmpLabel+1);
        fprintf(CODE, "\tmovl\t$0, %s\n", reg3);
        fprintf(CODE, ".L%d:\n", jmpLabel+2);
    }
    else if (isAND(comm)) {
        fprintf(CODE, "\tcmpl\t$0, %s\n", reg1);
        fprintf(CODE, "\tje\t.L%d\n", jmpLabel);
        fprintf(CODE, "\tcmpl\t$0, %s\n", reg2);
        fprintf(CODE, "\tje\t.L%d\n", jmpLabel);
        fprintf(CODE, "\tmovl\t$1, %s\n", reg3);
        fprintf(CODE, "\tjmp\t.L%d\n", jmpLabel+1);
        fprintf(CODE, ".L%d:\n", jmpLabel);
        fprintf(CODE, "\tmovl\t$0, %s\n", reg3);
        fprintf(CODE, ".L%d:\n", jmpLabel+1);
    }
    else if (isGE(comm)) {
        fprintf(CODE, "\tcmpl\t%s, %s\n", reg1, reg2);
        fprintf(CODE, "\tsetge\t%s\n", reg3);
    }
    else if (isGT(comm)) {
        fprintf(CODE, "\tcmpl\t%s, %s\n", reg1, reg2);
        fprintf(CODE, "\tsetg\t%s\n", reg3);
    }
    else if (isLE(comm)) {
        fprintf(CODE, "\tcmpl\t%s, %s\n", reg1, reg2);
        fprintf(CODE, "\tsetle\t%s\n", reg3);
    }
    else if (isLT(comm)) {
        fprintf(CODE, "\tcmpl\t%s, %s\n", reg1, reg2);
        fprintf(CODE, "\tsetl\t%s\n", reg3);
    }
    else if (isEQ(comm)) {
        fprintf(CODE, "\tcmpl\t%s, %s\n", reg1, reg2);
        fprintf(CODE, "\tsete\t%s\n", reg3);
    }
    else if (isNEQ(comm)) {
        fprintf(CODE, "\tcmpl\t%s, %s\n", reg1, reg2);
        fprintf(CODE, "\tsetne\t%s\n", reg3);
    }
}
static void genTextSection(FILE *IR) {
    fprintf(CODE, ".section\t.text\n");
    char line[512], line_back[512], currBlock[32];
    char *tok;
    static int currFinID = 0;

    memset(currBlock, 0, sizeof(currBlock));
    while (fgets(line, sizeof(line), IR) != NULL) {
        strcpy(line_back, line);
        switch (labelCheck(line_back)) {
            case 0:
                break;
            case -1:
                genInst(line);
                break;
            case 1:
                if (strlen(currBlock) != 0) {
                    fprintf(CODE, ".LFE%d:\n", currFinID++);
                    fprintf(CODE, "\t.size\t%s, .-%s\n\n", currBlock, currBlock);
                }
                fprintf(CODE, "\t.globl\tmain\n");
                fprintf(CODE, "\t.type\tmain,@function\n");
                fprintf(CODE, "main:\n");
                strcpy(currBlock, "main");
                makeStack(getMaxMemLoc(buckets));
                break;
            case 2:
                tok = strtok(line, " \r\n");
                if (strlen(currBlock) != 0) {
                    fprintf(CODE, ".LFE%d:\n", currFinID++);
                    fprintf(CODE, "\t.size\t%s, .-%s\n\n", currBlock, currBlock);
                }
                fprintf(CODE, "\t.globl\t %s\n", tok+8);
                fprintf(CODE, "\t.type\t %s,@function\n", tok+8);
                fprintf(CODE, "%s:\n", tok+8);
                strcpy(currBlock, tok);

                symbolNode *table = getBucketbyName(tok+8);
                makeStack(getMaxMemLoc(table));
                break;
            case 3:
                fprintf(CODE, "%s:\n", tok);
                break;
            case 4: // enter data section
                fprintf(CODE, ".LFE%d:\n", currFinID++);
                fprintf(CODE, "\t.size\t%s, .-%s\n\n", currBlock, currBlock);
                return;
        }
    }
}
static void genDataSection(FILE *IR) {
    fprintf(CODE, ".section\t.rodata\n");

    char line[512];
    while (fgets(line, sizeof(line), IR) != NULL) {
        fprintf(CODE, "data: %s\n", line);
    }
}
int genX86Asm(FILE *IR) {
    genPreDecl();
    // Code section
    genTextSection(IR);
    // Data section(for const value)
    genDataSection(IR);
    genPostDecl();
}

/* int main(int argc, char *argv[]) */
/* { */
    /* FILE *f = fopen("ir.txt", "rt"); */
    /* CODE = fopen("ir.s", "w"); */
    /* genX86Asm(f); */
    /* fclose(f); */
    /* fclose(CODE); */
    /* return 0; */
/* } */
